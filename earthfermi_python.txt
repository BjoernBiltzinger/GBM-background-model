l = math.sqrt(sat_dist**2 - r**2)
    
    A_hend = []
    
    for i in range(0, len(bin_time_mid)):
        def a(Phi, d = sat_dist, l = l, earth_ang = earth_ang, i = i):
            return 4*d**2 * l**2 *(math.cos(earth_ang[i])**2 + math.cos(Phi)**2 * math.sin(earth_ang[i])**2)
        def b(d = sat_dist, l = l, earth_ang = earth_ang, i = i, r = r):
            return 4*d*l*math.cos(earth_ang[i])*(r**2 - l**2 - d**2)
        def c(Phi, d = sat_dist, l = l, earth_ang = earth_ang, i = i, r = r):
            return (r**2 - l**2 -d**2)**2 - 4*d**2 * l**2 * math.cos(Phi)**2 * math.sin(earth_ang[i])**2
        def midnight(Phi, signum = 0):
            if signum ==0:
                val = (-b() + math.sqrt(b()**2 - 4*a(Phi)*c(Phi)))/(2*a(Phi))
            else:
                val = (-b() - math.sqrt(b()**2 - 4*a(Phi)*c(Phi)))/(2*a(Phi))
            return val
        def c_theta(Phi, ind, opening_ang = opening_ang):
            if ind ==0:
                cos = min(mignight(Phi, 1), math.cos(opening_ang))
            else:
                cos = min(mignight(Phi, 0), math.cos(opening_ang))
            return cos
        def phi1(d = sat_dist, l = l, earth_ang = earth_ang, i = i, r = r, opening_ang = opening_ang):
            c_phi1 = (l**2 + d**2 - r**2 - 2*d*l*math.cos(opening_ang)*math.cos(earth_ang[i]))/(2*d*l*math.sin(opening_ang)*math.sin(earth_ang[i]))
            p10 = math.acos(c_phi1)
            p11 = math.sqrt(-2*d**2 *((2*math.cos(earth_ang[i])**2 -1)*l**2 + r**2) + d**4 + (l**2 - r**2)**2)/(2*d*l*math.sin(earth_ang[i]))
            #p12 = -p12
            p13 = math.pi /2.
            #p14 = -p13
            return min(p10, p11, p13)
        
        def f(Phi, ind_1, ind_2):
            return -c_theta(Phi, ind = ind_1) + c_theta(Phi, ind = ind_2)
        area = integrate.quad(f, 0., phi1, args=(1., 0.))
        print i, area[0]
        A_hend.append(area[0])
    
    A_hend = np.array(A_hend)