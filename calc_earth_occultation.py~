#!/usr/bin python2.7

import subprocess
from subprocess import Popen, PIPE
import os
import matplotlib.pyplot as plt
import numpy as np
import math
import pyfits
from numpy import linalg as LA
import ephem
from scipy import interpolate
import scipy.optimize as optimization
from scipy import integrate
from astropy.time import Time
from astropy.table import Table
from astropy.io import fits
import fileinput
from datetime import datetime
from work_module import calculate
from work_module import detector
from work_module import readfile
from work_module import writefile
calc = calculate()
det = detector()
rf = readfile()
wf = writefile()

day = 150926
detector = det.n5

poshist = rf.poshist_bin(day, 0, detector)
sat_time_bin = poshist[0]
sat_pos_bin = poshist[1]
sat_lat_bin = poshist[2]
sat_lon_bin = poshist[3]
bin_time_mid = poshist[5]

sat_dist = LA.norm(sat_pos_bin, axis=0)

#earth_radius
ell_a = 6378137
ell_b = 6356752.3142
sat_lat_rad = sat_lat_bin*2*math.pi/360.
earth_radius_sat = ell_a * ell_b / ((ell_a**2 * np.sin(sat_lat_rad)**2 + ell_b**2 * np.cos(sat_lat_rad)**2)**0.5)
earth_radius = 6371000.8

atmosphere = 20000

earth_ang = calc.earth_ang_bin(detector, day, bin_time_mid)[0]
opening_ang = 80.0

r = earth_radius + atmosphere #not exactly, since the average earth radius is used
theta = np.arcsin(r/sat_dist)*360/(2*math.pi) #opening angle of the earth-cone
contur_ang = earth_ang - theta #angle between the detector direction and the horizon of the earth
hor_dist = (sat_dist)**2 - r**2 #distance of the horizon to the satellite
x = hor_dist*np.cos(contur_ang*2*math.pi/360) #x-distance of the earth in the plane of the detector direction and the earth direction (not sure whether this is needed)
y = hor_dist*np.sin(contur_ang*2*math.pi/360) #y-distance of the earth in the plane of the detector direction and the earth direction (not sure whether this is needed)
d = x*np.tan(opening_ang*2*math.pi/360) #radius of the detector cone at the x-distance of the earth (not sure whether this is needed)

l = r+d-y #self-defined parameter (not sure whether this is needed

#try out the spherical caps crosssection

f = -1/(np.tan(earth_ang*2*math.pi/360))*(np.cos(opening_ang*2*math.pi/360) - (np.cos(theta*2*math.pi/360))/(np.cos(earth_ang*2*math.pi/360))*(2*(np.cos(earth_ang*2*math.pi/360))**2 - 1)) #distance perpendicular to the detector-orientation to the intersection-plane of the spherical caps

beta = np.arctan2(f,(np.cos(opening_ang*2*math.pi/360)))*360/(2*math.pi) #angle of the intersection-plane to the detector orientation

a = np.sqrt(1 - f**2 - (np.cos(opening_ang))**2) #diagonal of the overlapping crosssections of the spherical caps

gamma_max = np.arctan(a/(2*f)) #angle of the intersectionpoints on the plane perpendicular to the detector-orientation (top-view)

#phi_min = np.arctan(np.tan(beta)/np.cos(gamma))

A_d = []

for i in range(0, len(bin_time_mid)):
    def f(phi, gamma):
        return math.sin(phi)
    def bounds_y():
        return [-gamma_max[i], gamma_max[i]]
    def bounds_x(gamma):
        return [math.atan2(math.tan(beta[i]*2*math.pi/360),math.cos(gamma)), opening_ang*2*math.pi/360]
    area = integrate.nquad(f, [bounds_x, bounds_y])
    print i, area[0]
    A_d.append(area[0])

A_d = np.array(A_d)


'''A_d2 = []

for i in range(0, len(bin_time_mid)):
    def f(gamma, phi):
        return math.sin(phi)
    def bounds_y():
        return [beta[i], opening_ang]
    def bounds_x(phi):
        return [-math.acos(math.tan(beta[i]*2*math.pi/360)/math.tan(phi*2*math.pi/360)), math.acos(math.tan(beta[i]*2*math.pi/360)/math.tan(phi*2*math.pi/360))]
    area = integrate.nquad(f, [bounds_x, bounds_y])
    print i, area[0]
    A_d2.append(area[0])

A_d2 = np.array(A_d)'''



A_d_an = ((np.sign(np.cos(gamma_max)))*np.arcsin(np.fabs(np.cos(beta*2*math.pi/360))*np.sin(gamma_max))) - ((np.sign(np.cos(-gamma_max)))*np.arcsin(np.fabs(np.cos(beta*2*math.pi/360))*np.sin(-gamma_max)))

A_d_an2 = 2*(np.arctan2((np.sqrt(-(np.tan(beta*2*math.pi/360))**2/((np.sin(opening_ang*2*math.pi/360))**2) + (np.tan(beta*2*math.pi/360))**2 + 1)*np.sin(opening_ang*2*math.pi/360)),np.tan(beta*2*math.pi/360))-np.cos(opening_ang*2*math.pi/360)*np.arccos(np.tan(beta*2*math.pi/360)/np.tan(opening_ang*2*math.pi/360)) - (np.arctan2((np.sqrt(-(np.tan(beta*2*math.pi/360))**2/((np.sin(beta*2*math.pi/360))**2) + (np.tan(beta*2*math.pi/360))**2 + 1)*np.sin(beta*2*math.pi/360)),np.tan(beta*2*math.pi/360))-np.cos(beta*2*math.pi/360)*np.arccos(np.tan(beta*2*math.pi/360)/np.tan(beta*2*math.pi/360))))


'''a[np.where(beta > opening_ang)] = 0.

contur_ang[np.where(contur_ang < 0.)] = contur_ang[np.where(contur_ang < 0.)] + 360.

area_fraction = np.ones(len(sat_time_bin))

area_fraction[np.where(contur_ang < opening_ang)] = '''

'''test = d**2 - ((d**2 + y**2 - r**2)/(2*y))**2
print test
print len(np.where(d < (sat_dist - earth_radius))[0])
print len(np.where(d < y)[0])
print len(np.where(test < 0.)[0])
print len(test)
print len(np.where(np.fabs(contur_ang) > opening_ang)[0])'''


'''s = 2*(d**2 - (d**2 + y**2 - r**2)/(2*y))**(0.5)

alpha_d = 2*np.arcsin(s/(2*d))
alpha_e = 2*np.arcsin(s/(2*r))

area_d = ((d**2)/2)*(alpha_d - np.sin(alpha_d))
area_e = ((r**2)/2)*(alpha_e - np.sin(alpha_e))'''


fig, ax1 = plt.subplots()
ax2 = ax1.twinx()

plot1 = ax1.plot(sat_time_bin, A_d, 'b-')
#plot4 = ax1.plot(sat_time_bin, A_d2, 'r-')
plot2 = ax1.plot(sat_time_bin, A_d_an, 'y--')
plot3 = ax1.plot(sat_time_bin, A_d_an2, 'g--')
plot6 = ax1.plot(sat_time_bin, A_d - A_d_an2, 'g-')
plot5 = ax2.plot(sat_time_bin, earth_ang, 'r-')
plot7 = ax2.plot(sat_time_bin, opening_ang + theta, 'y-' )

#ax1.set_xlim([0, 24.1])
#ax1.set_ylim([-500, 500])
#ax2.set_xlim([0, 24.1])
#ax2.set_ylim([-40, 80])

plt.show()
